<script lang="tsx" setup generic="T extends AnyObject = AnyObject">
import { computed, getCurrentInstance, toRefs, type AriaAttributes, type CSSProperties } from 'vue';
import type { AnyObject } from '../_util/type';
import { useComponentConfig } from '../config-provider/context';
import type { DropdownProps } from '../dropdown';
import { BreadcrumbContextProvider, type BreadcrumbContextProps } from './BreadcrumbContext';
import type { BreadcrumbItemProps } from './BreadcrumbItem.vue';
import BreadcrumbSeparator from './BreadcrumbSeparator.vue';
import useStyle from './style';
import useItemRender from './useItemRender';
import type { VueKey, VueNode } from '@/vc-util/type';
import clsx from 'clsx';
import Render from '@/vc-component/render';
import InternalBreadcrumbItem from './InternalBreadcrumbItem.vue';
import pickAttrs from '@/vc-util/pickAttrs';
import type { SemanticClassNamesType, SemanticStylesType } from '../_util/hooks/useMergeSemantic';
import useMergeSemantic from '../_util/hooks/useMergeSemantic';

export interface BreadcrumbItemType extends /** @vue-ignore */ AriaAttributes {
  key?: VueKey;
  /**
   * Different with `path`. Directly set the link of this item.
   */
  href?: string;
  /**
   * Different with `href`. It will concat all prev `path` to the current one.
   */
  path?: string;
  title?: VueNode;
  menu?: BreadcrumbItemProps['menu'];
  class?: string;
  style?: CSSProperties;
  dropdownProps?: DropdownProps;
  onClick?: (e: MouseEvent) => void;
  [key: `data-${string}`]: string;
}

export interface BreadcrumbSeparatorType {
  type: 'separator';
  separator?: VueNode;
}

export type ItemType = Partial<BreadcrumbItemType & BreadcrumbSeparatorType>;

export type InternalRouteType = Partial<BreadcrumbItemType & BreadcrumbSeparatorType>;

export type BreadcrumbSemanticName = 'root' | 'item' | 'separator';

export type BreadcrumbClassNamesType<T extends AnyObject = AnyObject> = SemanticClassNamesType<
  BreadcrumbProps<T>,
  BreadcrumbSemanticName
>;

export type BreadcrumbStylesType<T extends AnyObject = AnyObject> = SemanticStylesType<
  BreadcrumbProps<T>,
  BreadcrumbSemanticName
>;

export interface BreadcrumbProps<T extends AnyObject = AnyObject> {
  prefixCls?: string;
  params?: T;
  separator?: VueNode;
  style?: CSSProperties;
  class?: string;
  rootClassName?: string;
  items?: ItemType[];
  classNames?: BreadcrumbClassNamesType<T>;
  styles?: BreadcrumbStylesType<T>;

  itemRender?: (route: ItemType, params: T, routes: ItemType[], paths: string[]) => VueNode;
}

defineOptions({ name: 'Breadcurmb', inheritAttrs: false, compatConfig: { MODE: 3 } });

const {
  prefixCls: customizePrefixCls,
  separator = '/',
  style,
  class: className,
  rootClassName,
  items,
  itemRender,
  params = {},
  classNames: breadcrumbClassNames,
  styles,
  ...restProps
} = defineProps<BreadcrumbProps<T>>();

const getPath = <T extends AnyObject = AnyObject>(params: T, path?: string) => {
  if (path === undefined) {
    return path;
  }
  let mergedPath = (path || '').replace(/^\//, '');
  Object.keys(params).forEach((key) => {
    mergedPath = mergedPath.replace(`:${key}`, params[key]!);
  });
  return mergedPath;
};

const {
  getPrefixCls,
  direction,
  class: contextClassName,
  style: contextStyle,
  classNames: contextClassNames,
  styles: contextStyles,
} = toRefs(useComponentConfig('breadcrumb'));

const prefixCls = computed(() => getPrefixCls.value('breadcrumb', customizePrefixCls));
const [hashId, cssVarCls] = useStyle(prefixCls);

// =========== Merged Props for Semantic ==========
const vm = getCurrentInstance();
const mergedProps = computed(() => {
  return {
    ...vm.props,
  } as BreadcrumbProps<T>;
});

// ========================= Style ==========================
const [mergedClassNames, mergedStyles] = useMergeSemantic<
  BreadcrumbClassNamesType<T>,
  BreadcrumbStylesType<T>,
  BreadcrumbProps<T>
>(
  computed(() => [contextClassNames?.value as any, breadcrumbClassNames]),
  computed(() => [contextStyles?.value as any, styles]),
  undefined,
  computed(() => ({
    props: mergedProps.value,
  })),
);

const mergedItemRender = useItemRender(
  prefixCls,
  computed(() => itemRender as any),
);

const Crumbs = () => {
  let crumbs;
  if (items && items.length > 0) {
    // generated by route
    const paths: string[] = [];

    crumbs = items.map((item, index) => {
      const { path, key, type, menu, onClick, class: itemClassName, style, separator: itemSeparator, dropdownProps } = item;
      const mergedPath = getPath(params, path);

      if (mergedPath !== undefined) {
        paths.push(mergedPath);
      }

      const mergedKey = key ?? index;

      if (type === 'separator') {
        return (
          <BreadcrumbSeparator key={mergedKey}>{itemSeparator && <Render content={itemSeparator}></Render>}</BreadcrumbSeparator>
        );
      }

      const itemProps: BreadcrumbItemProps = {};
      const isLastItem = index === items.length - 1;

      if (menu) {
        itemProps.menu = menu;
      }

      let { href } = item;
      if (paths.length && mergedPath !== undefined) {
        href = `#/${paths.join('/')}`;
      }

      return (
        <InternalBreadcrumbItem
          key={mergedKey}
          {...itemProps}
          {...pickAttrs(item, { data: true, aria: true })}
          class={itemClassName}
          style={style}
          dropdownProps={dropdownProps}
          href={href}
          separator={isLastItem ? '' : separator}
          onClick={onClick}
          prefixCls={prefixCls.value}
        >
          {mergedItemRender.value(item, params, items!, paths, href)}
        </InternalBreadcrumbItem>
      );
    });
  }
  return crumbs;
};

const breadcrumbClassName = computed(() =>
  clsx(
    prefixCls.value,
    contextClassName?.value,
    {
      [`${prefixCls.value}-rtl`]: direction.value === 'rtl',
    },
    className,
    rootClassName,
    mergedClassNames?.value?.root,
    hashId.value,
    cssVarCls.value,
  ),
);

const mergedStyle = computed<CSSProperties>(() => ({
  ...mergedStyles?.value?.root,
  ...contextStyle?.value,
  ...style,
}));

const memoizedValue = computed<BreadcrumbContextProps>(() => ({
  classNames: mergedClassNames.value,
  styles: mergedStyles.value,
}));
</script>
<template>
  <BreadcrumbContextProvider :value="memoizedValue">
    <nav :class="breadcrumbClassName" :style="mergedStyle" v-bind="{ ...restProps, ...$attrs }">
      <ol>
        <Crumbs />
      </ol>
    </nav>
  </BreadcrumbContextProvider>
</template>
